OPEN(2)                             Linux Programmer's Manual                            OPEN(2)

NNAAMMEE
       open, openat, creat - open and possibly create a file

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ssyyss//ttyyppeess..hh>>
       ##iinncclluuddee <<ssyyss//ssttaatt..hh>>
       ##iinncclluuddee <<ffccnnttll..hh>>

       iinntt ooppeenn((ccoonnsstt cchhaarr **_p_a_t_h_n_a_m_e,, iinntt _f_l_a_g_s));;
       iinntt ooppeenn((ccoonnsstt cchhaarr **_p_a_t_h_n_a_m_e,, iinntt _f_l_a_g_s,, mmooddee__tt _m_o_d_e));;

       iinntt ccrreeaatt((ccoonnsstt cchhaarr **_p_a_t_h_n_a_m_e,, mmooddee__tt _m_o_d_e));;

       iinntt ooppeennaatt((iinntt _d_i_r_f_d,, ccoonnsstt cchhaarr **_p_a_t_h_n_a_m_e,, iinntt _f_l_a_g_s));;
       iinntt ooppeennaatt((iinntt _d_i_r_f_d,, ccoonnsstt cchhaarr **_p_a_t_h_n_a_m_e,, iinntt _f_l_a_g_s,, mmooddee__tt _m_o_d_e));;

   Feature Test Macro Requirements for glibc (see ffeeaattuurree__tteesstt__mmaaccrrooss(7)):

       ooppeennaatt():
           Since glibc 2.10:
               _XOPEN_SOURCE >= 700 || _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DDEESSCCRRIIPPTTIIOONN
       Given a _p_a_t_h_n_a_m_e for a file, ooppeenn() returns a file descriptor, a small, nonnegative inte‐
       ger for use in subsequent system calls (rreeaadd(2),  wwrriittee(2),  llsseeeekk(2),  ffccnnttll(2),  etc.).
       The  file  descriptor  returned  by  a  successful  call will be the lowest-numbered file
       descriptor not currently open for the process.

       By default, the new file descriptor is set to remain open across an eexxeeccvvee(2) (i.e.,  the
       FFDD__CCLLOOEEXXEECC  file  descriptor  flag  described  in  ffccnnttll(2)  is  initially disabled); the
       OO__CCLLOOEEXXEECC flag, described below, can be used to change this default.  The file offset  is
       set to the beginning of the file (see llsseeeekk(2)).

       A  call  to ooppeenn() creates a new _o_p_e_n _f_i_l_e _d_e_s_c_r_i_p_t_i_o_n, an entry in the system-wide table
       of open files.  The open file description records the file offset  and  the  file  status
       flags  (see  below).   A file descriptor is a reference to an open file description; this
       reference is unaffected if _p_a_t_h_n_a_m_e is subsequently removed or modified  to  refer  to  a
       different file.  For further details on open file descriptions, see NOTES.

       The argument _f_l_a_g_s must include one of the following _a_c_c_e_s_s _m_o_d_e_s: OO__RRDDOONNLLYY, OO__WWRROONNLLYY, or
       OO__RRDDWWRR.  These request opening the file read-only,  write-only,  or  read/write,  respec‐
       tively.

       In  addition,  zero or more file creation flags and file status flags can be bitwise-_o_r'd
       in _f_l_a_g_s.  The _f_i_l_e _c_r_e_a_t_i_o_n _f_l_a_g_s are OO__CCLLOOEEXXEECC, OO__CCRREEAATT, OO__DDIIRREECCTTOORRYY, OO__EEXXCCLL, OO__NNOOCCTTTTYY,
       OO__NNOOFFOOLLLLOOWW, OO__TTMMPPFFIILLEE, and OO__TTRRUUNNCC.  The _f_i_l_e _s_t_a_t_u_s _f_l_a_g_s are all of the remaining flags
       listed below.  The distinction between these two groups of flags is that the file  status
       flags can be retrieved and (in some cases) modified; see ffccnnttll(2) for details.

       The full list of file creation flags and file status flags is as follows:

       OO__AAPPPPEENNDD
              The file is opened in append mode.  Before each wwrriittee(2), the file offset is posi‐
              tioned at the end of the file, as if with llsseeeekk(2).  OO__AAPPPPEENNDD  may  lead  to  cor‐
              rupted files on NFS filesystems if more than one process appends data to a file at
              once.  This is because NFS does not support appending to a  file,  so  the  client
              kernel has to simulate it, which can't be done without a race condition.

       OO__AASSYYNNCC
              Enable  signal-driven  I/O:  generate  a signal (SSIIGGIIOO by default, but this can be
              changed via ffccnnttll(2)) when input or output becomes possible on this file  descrip‐
              tor.   This feature is available only for terminals, pseudoterminals, sockets, and
              (since Linux 2.6) pipes and FIFOs.  See ffccnnttll(2) for further  details.   See  also
              BUGS, below.

       OO__CCLLOOEEXXEECC (since Linux 2.6.23)
              Enable  the  close-on-exec flag for the new file descriptor.  Specifying this flag
              permits a program to avoid additional  ffccnnttll(2)  FF__SSEETTFFDD  operations  to  set  the
              FFDD__CCLLOOEEXXEECC flag.

              Note  that  the  use  of  this  flag  is essential in some multithreaded programs,
              because using a separate ffccnnttll(2) FF__SSEETTFFDD operation to  set  the  FFDD__CCLLOOEEXXEECC  flag
              does not suffice to avoid race conditions where one thread opens a file descriptor
              and attempts to set its close-on-exec flag using ffccnnttll(2)  at  the  same  time  as
              another  thread  does  a ffoorrkk(2) plus eexxeeccvvee(2).  Depending on the order of execu‐
              tion, the race may lead to the file descriptor returned by ooppeenn()  being  uninten‐
              tionally  leaked  to the program executed by the child process created by ffoorrkk(2).
              (This kind of race is in principle possible for any system  call  that  creates  a
              file  descriptor  whose  close-on-exec flag should be set, and various other Linux
              system calls provide an equivalent of the OO__CCLLOOEEXXEECC flag to deal with  this  prob‐
              lem.)

       OO__CCRREEAATT
              If  the  file does not exist, it will be created.  The owner (user ID) of the file
              is set to the effective user ID of the process.  The group ownership (group ID) is
              set either to the effective group ID of the process or to the group ID of the par‐
              ent directory (depending on filesystem type and mount options, and the mode of the
              parent  directory;  see  the  mount  options _b_s_d_g_r_o_u_p_s and _s_y_s_v_g_r_o_u_p_s described in
              mmoouunntt(8)).

              _m_o_d_e specifies the mode to use in case a new file is created.  This argument  must
              be  supplied  when  OO__CCRREEAATT or OO__TTMMPPFFIILLEE is specified in _f_l_a_g_s; if neither OO__CCRREEAATT
              nor OO__TTMMPPFFIILLEE is specified, then _m_o_d_e is ignored.  The effective mode is  modified
              by the process's _u_m_a_s_k in the usual way: in the absence of a default ACL, the mode
              of the created file is _(_m_o_d_e _& _~_u_m_a_s_k_).  Note  that  this  mode  applies  only  to
              future  accesses  of  the newly created file; the ooppeenn() call that creates a read-
              only file may well return a read/write file descriptor.

              The following symbolic constants are provided for _m_o_d_e:

              SS__IIRRWWXXUU  00700 user (file owner) has read, write, and execute permission

              SS__IIRRUUSSRR  00400 user has read permission

              SS__IIWWUUSSRR  00200 user has write permission

              SS__IIXXUUSSRR  00100 user has execute permission

              SS__IIRRWWXXGG  00070 group has read, write, and execute permission

              SS__IIRRGGRRPP  00040 group has read permission

              SS__IIWWGGRRPP  00020 group has write permission

              SS__IIXXGGRRPP  00010 group has execute permission

              SS__IIRRWWXXOO  00007 others have read, write, and execute permission

              SS__IIRROOTTHH  00004 others have read permission

              SS__IIWWOOTTHH  00002 others have write permission

              SS__IIXXOOTTHH  00001 others have execute permission

              According to POSIX, the effect when other bits are set in _m_o_d_e is unspecified.  On
              Linux, the following bits are also honored in _m_o_d_e:

              SS__IISSUUIIDD  0004000 set-user-ID bit

              SS__IISSGGIIDD  0002000 set-group-ID bit (see ssttaatt(2))

              SS__IISSVVTTXX  0001000 sticky bit (see ssttaatt(2))

       OO__DDIIRREECCTT (since Linux 2.4.10)
              Try  to  minimize cache effects of the I/O to and from this file.  In general this
              will degrade performance, but it is useful in special  situations,  such  as  when
              applications  do  their own caching.  File I/O is done directly to/from user-space
              buffers.  The OO__DDIIRREECCTT flag on its own makes  an  effort  to  transfer  data  syn‐
              chronously, but does not give the guarantees of the OO__SSYYNNCC flag that data and nec‐
              essary metadata are transferred.  To guarantee synchronous  I/O,  OO__SSYYNNCC  must  be
              used in addition to OO__DDIIRREECCTT.  See NOTES below for further discussion.

              A  semantically  similar (but deprecated) interface for block devices is described
              in rraaww(8).

       OO__DDIIRREECCTTOORRYY
              If _p_a_t_h_n_a_m_e is not a directory, cause the open to fail.  This flag  was  added  in
              kernel  version  2.1.126,  to  avoid  denial-of-service  problems if ooppeennddiirr(3) is
              called on a FIFO or tape device.

       OO__DDSSYYNNCC
              Write operations on the file will complete according to the requirements  of  syn‐
              chronized I/O _d_a_t_a integrity completion.

              By the time wwrriittee(2) (and similar) return, the output data has been transferred to
              the underlying hardware, along with any file metadata that would  be  required  to
              retrieve that data (i.e., as though each wwrriittee(2) was followed by a call to ffddaattaa‐‐
              ssyynncc(2)).  _S_e_e _N_O_T_E_S _b_e_l_o_w.

       OO__EEXXCCLL Ensure that this call creates the file: if this flag is specified  in  conjunction
              with OO__CCRREEAATT, and _p_a_t_h_n_a_m_e already exists, then ooppeenn() will fail.

              When  these  two flags are specified, symbolic links are not followed: if _p_a_t_h_n_a_m_e
              is a symbolic link, then ooppeenn() fails regardless of where the symbolic link points
              to.

              In  general,  the  behavior  of OO__EEXXCCLL is undefined if it is used without OO__CCRREEAATT.
              There is one exception: on Linux 2.6 and later, OO__EEXXCCLL can be used without OO__CCRREEAATT
              if _p_a_t_h_n_a_m_e refers to a block device.  If the block device is in use by the system
              (e.g., mounted), ooppeenn() fails with the error EEBBUUSSYY.

              On NFS, OO__EEXXCCLL is supported only when using NFSv3 or later on kernel 2.6 or later.
              In NFS environments where OO__EEXXCCLL support is not provided, programs that rely on it
              for performing locking tasks will contain a  race  condition.   Portable  programs
              that  want  to  perform  atomic  file  locking using a lockfile, and need to avoid
              reliance on NFS support for OO__EEXXCCLL, can create a unique file on the same  filesys‐
              tem  (e.g., incorporating hostname and PID), and use lliinnkk(2) to make a link to the
              lockfile.  If lliinnkk(2) returns 0, the lock is successful.  Otherwise,  use  ssttaatt(2)
              on  the  unique  file to check if its link count has increased to 2, in which case
              the lock is also successful.

       OO__LLAARRGGEEFFIILLEE
              (LFS) Allow files whose sizes cannot be represented in an _o_f_f___t (but can be repre‐
              sented in an _o_f_f_6_4___t) to be opened.  The __LLAARRGGEEFFIILLEE6644__SSOOUURRCCEE macro must be defined
              (before including _a_n_y header files) in order to obtain this  definition.   Setting
              the  __FFIILLEE__OOFFFFSSEETT__BBIITTSS feature test macro to 64 (rather than using OO__LLAARRGGEEFFIILLEE) is
              the preferred method  of  accessing  large  files  on  32-bit  systems  (see  ffeeaa‐‐
              ttuurree__tteesstt__mmaaccrrooss(7)).

       OO__NNOOAATTIIMMEE (since Linux 2.6.8)
              Do  not  update the file last access time (_s_t___a_t_i_m_e in the inode) when the file is
              rreeaadd(2).  This flag is intended for use by indexing or backup programs, where  its
              use  can  significantly  reduce the amount of disk activity.  This flag may not be
              effective on all filesystems.  One example is NFS, where the server maintains  the
              access time.

       OO__NNOOCCTTTTYY
              If  _p_a_t_h_n_a_m_e  refers  to  a  terminal  device—see  ttttyy(4)—it  will  not become the
              process's controlling terminal even if the process does not have one.

       OO__NNOOFFOOLLLLOOWW
              If _p_a_t_h_n_a_m_e is a symbolic link, then the open fails.  This is a FreeBSD extension,
              which was added to Linux in version 2.1.126.  Symbolic links in earlier components
              of the pathname will still be followed.  See also OO__PPAATTHH below.

       OO__NNOONNBBLLOOCCKK or OO__NNDDEELLAAYY
              When possible, the file is opened in nonblocking mode.  Neither the ooppeenn() nor any
              subsequent  operations  on  the  file  descriptor which is returned will cause the
              calling process to wait.

              Note that this flag has no effect for regular files and block  devices;  that  is,
              I/O  operations  will (briefly) block when device activity is required, regardless
              of whether OO__NNOONNBBLLOOCCKK is set.  Since  OO__NNOONNBBLLOOCCKK  semantics  might  eventually  be
              implemented, applications should not depend upon blocking behavior when specifying
              this flag for regular files and block devices.

              For the handling of FIFOs (named pipes), see also ffiiffoo(7).  For  a  discussion  of
              the  effect  of  OO__NNOONNBBLLOOCCKK in conjunction with mandatory file locks and with file
              leases, see ffccnnttll(2).

       OO__PPAATTHH (since Linux 2.6.39)
              Obtain a file descriptor that can be used for two purposes: to indicate a location
              in  the  filesystem  tree  and  to  perform operations that act purely at the file
              descriptor level.  The file itself is not opened, and other file operations (e.g.,
              rreeaadd(2),  wwrriittee(2),  ffcchhmmoodd(2),  ffcchhoowwnn(2),  ffggeettxxaattttrr(2),  mmmmaapp(2)) fail with the
              error EEBBAADDFF.

              The following operations _c_a_n be performed on the resulting file descriptor:

              *  cclloossee(2); ffcchhddiirr(2) (since Linux 3.5); ffssttaatt(2) (since Linux 3.6).

              *  Duplicating the file descriptor (dduupp(2), ffccnnttll(2) FF__DDUUPPFFDD, etc.).

              *  Getting and setting file descriptor flags (ffccnnttll(2) FF__GGEETTFFDD and FF__SSEETTFFDD).

              *  Retrieving open file status flags using the  ffccnnttll(2)  FF__GGEETTFFLL  operation:  the
                 returned flags will include the bit OO__PPAATTHH.

              *  Passing  the  file  descriptor as the _d_i_r_f_d argument of ooppeennaatt(2) and the other
                 "*at()" system calls.  This  includes  lliinnkkaatt(2)  with  AATT__EEMMPPTTYY__PPAATTHH  (or  via
                 procfs using AATT__SSYYMMLLIINNKK__FFOOLLLLOOWW) even if the file is not a directory.

              *  Passing  the  file  descriptor to another process via a UNIX domain socket (see
                 SSCCMM__RRIIGGHHTTSS in uunniixx(7)).

              When OO__PPAATTHH is specified in _f_l_a_g_s, flag bits other  than  OO__CCLLOOEEXXEECC,  OO__DDIIRREECCTTOORRYY,
              and OO__NNOOFFOOLLLLOOWW are ignored.

              If _p_a_t_h_n_a_m_e is a symbolic link and the OO__NNOOFFOOLLLLOOWW flag is also specified, then the
              call returns a file descriptor referring to the symbolic link.  This file descrip‐
              tor  can  be  used  as  the  _d_i_r_f_d  argument  in calls to ffcchhoowwnnaatt(2), ffssttaattaatt(2),
              lliinnkkaatt(2), and rreeaaddlliinnkkaatt(2) with an empty pathname to have the calls  operate  on
              the symbolic link.

       OO__SSYYNNCC Write  operations  on the file will complete according to the requirements of syn‐
              chronized I/O _f_i_l_e integrity completion (by contrast  with  the  synchronized  I/O
              _d_a_t_a integrity completion provided by OO__DDSSYYNNCC.)

              By  the  time  wwrriittee(2)  (and similar) return, the output data and associated file
              metadata have been transferred to the underlying hardware (i.e.,  as  though  each
              wwrriittee(2) was followed by a call to ffssyynncc(2)).  _S_e_e _N_O_T_E_S _b_e_l_o_w.

       OO__TTMMPPFFIILLEE (since Linux 3.11)
              Create an unnamed temporary file.  The _p_a_t_h_n_a_m_e argument specifies a directory; an
              unnamed inode will be created in that directory's filesystem.  Anything written to
              the  resulting  file  will be lost when the last file descriptor is closed, unless
              the file is given a name.

              OO__TTMMPPFFIILLEE must be specified with  one  of  OO__RRDDWWRR  or  OO__WWRROONNLLYY  and,  optionally,
              OO__EEXXCCLL.  If OO__EEXXCCLL is not specified, then lliinnkkaatt(2) can be used to link the tempo‐
              rary file into the filesystem, making it permanent, using code like the following:

                  char path[PATH_MAX];
                  fd = open("/path/to/dir", O_TMPFILE | O_RDWR,
                                          S_IRUSR | S_IWUSR);

                  /* File I/O on 'fd'... */

                  snprintf(path, PATH_MAX,  "/proc/self/fd/%d", fd);
                  linkat(AT_FDCWD, path, AT_FDCWD, "/path/for/file",
                                          AT_SYMLINK_FOLLOW);

              In this case, the ooppeenn() _m_o_d_e argument determines the  file  permission  mode,  as
              with OO__CCRREEAATT.

              Specifying  OO__EEXXCCLL  in  conjunction  with OO__TTMMPPFFIILLEE prevents a temporary file from
              being linked into the filesystem in the above manner.  (Note that the  meaning  of
              OO__EEXXCCLL in this case is different from the meaning of OO__EEXXCCLL otherwise.)

              There are two main use cases for OO__TTMMPPFFIILLEE:

              *  Improved  ttmmppffiillee(3)  functionality: race-free creation of temporary files that
                 (1) are automatically deleted when closed; (2) can never  be  reached  via  any
                 pathname;  (3)  are  not subject to symlink attacks; and (4) do not require the
                 caller to devise unique names.

              *  Creating a file that is initially invisible, which is then populated with  data
                 and  adjusted  to  have  appropriate filesystem attributes (cchhoowwnn(2), cchhmmoodd(2),
                 ffsseettxxaattttrr(2), etc.)  before being atomically linked into the  filesystem  in  a
                 fully formed state (using lliinnkkaatt(2) as described above).

              OO__TTMMPPFFIILLEE  requires  support  by the underlying filesystem; only a subset of Linux
              filesystems provide that support.  In the initial implementation, support was pro‐
              vided in the ext2, ext3, ext4, UDF, Minix, and shmem filesystems.  XFS support was
              added in Linux 3.15.

       OO__TTRRUUNNCC
              If the file already exists and is a regular file and the access mode allows  writ‐
              ing  (i.e.,  is OO__RRDDWWRR or OO__WWRROONNLLYY) it will be truncated to length 0.  If the file
              is a FIFO or terminal device file, the OO__TTRRUUNNCC flag is  ignored.   Otherwise,  the
              effect of OO__TTRRUUNNCC is unspecified.

   ccrreeaatt(())
       ccrreeaatt() is equivalent to ooppeenn() with _f_l_a_g_s equal to OO__CCRREEAATT||OO__WWRROONNLLYY||OO__TTRRUUNNCC.

   ooppeennaatt(())
       The  ooppeennaatt() system call operates in exactly the same way as ooppeenn(), except for the dif‐
       ferences described here.

       If the pathname given in _p_a_t_h_n_a_m_e is relative, then it is  interpreted  relative  to  the
       directory  referred  to by the file descriptor _d_i_r_f_d (rather than relative to the current
       working directory of the calling process, as is done by ooppeenn() for a relative pathname).

       If _p_a_t_h_n_a_m_e is relative and _d_i_r_f_d is the special value AATT__FFDDCCWWDD, then _p_a_t_h_n_a_m_e is  inter‐
       preted relative to the current working directory of the calling process (like ooppeenn()).

       If _p_a_t_h_n_a_m_e is absolute, then _d_i_r_f_d is ignored.

RREETTUURRNN VVAALLUUEE
       ooppeenn(),  ooppeennaatt(), and ccrreeaatt() return the new file descriptor, or -1 if an error occurred
       (in which case, _e_r_r_n_o is set appropriately).

EERRRROORRSS
       ooppeenn(), ooppeennaatt(), and ccrreeaatt() can fail with the following errors:

       EEAACCCCEESS The requested access to the file is not allowed, or search  permission  is  denied
              for  one  of  the  directories in the path prefix of _p_a_t_h_n_a_m_e, or the file did not
              exist yet and write access to the parent directory  is  not  allowed.   (See  also
              ppaatthh__rreessoolluuttiioonn(7).)

       EEDDQQUUOOTT Where  OO__CCRREEAATT is specified, the file does not exist, and the user's quota of disk
              blocks or inodes on the filesystem has been exhausted.

       EEEEXXIISSTT _p_a_t_h_n_a_m_e already exists and OO__CCRREEAATT and OO__EEXXCCLL were used.

       EEFFAAUULLTT _p_a_t_h_n_a_m_e points outside your accessible address space.

       EEFFBBIIGG  See EEOOVVEERRFFLLOOWW.

       EEIINNTTRR  While blocked waiting to complete an open of a slow  device  (e.g.,  a  FIFO;  see
              ffiiffoo(7)), the call was interrupted by a signal handler; see ssiiggnnaall(7).

       EEIINNVVAALL The  filesystem  does  not support the OO__DDIIRREECCTT flag.  See NNOOTTEESS for more informa‐
              tion.

       EEIINNVVAALL Invalid value in _f_l_a_g_s.

       EEIINNVVAALL OO__TTMMPPFFIILLEE was specified in _f_l_a_g_s, but neither OO__WWRROONNLLYY nor OO__RRDDWWRR was specified.

       EEIISSDDIIRR _p_a_t_h_n_a_m_e refers to a directory and the access requested involved writing (that is,
              OO__WWRROONNLLYY or OO__RRDDWWRR is set).

       EEIISSDDIIRR _p_a_t_h_n_a_m_e  refers to an existing directory, OO__TTMMPPFFIILLEE and one of OO__WWRROONNLLYY or OO__RRDDWWRR
              were specified in _f_l_a_g_s, but this kernel version does not  provide  the  OO__TTMMPPFFIILLEE
              functionality.

       EELLOOOOPP  Too many symbolic links were encountered in resolving _p_a_t_h_n_a_m_e.

       EELLOOOOPP  _p_a_t_h_n_a_m_e was a symbolic link, and _f_l_a_g_s specified OO__NNOOFFOOLLLLOOWW but not OO__PPAATTHH.

       EEMMFFIILLEE The per-process limit on the number of open file descriptors has been reached (see
              the description of RRLLIIMMIITT__NNOOFFIILLEE in ggeettrrlliimmiitt(2)).

       EENNAAMMEETTOOOOLLOONNGG
              _p_a_t_h_n_a_m_e was too long.

       EENNFFIILLEE The system-wide limit on the total number of open files has been reached.

       EENNOODDEEVV _p_a_t_h_n_a_m_e refers to a device special  file  and  no  corresponding  device  exists.
              (This is a Linux kernel bug; in this situation EENNXXIIOO must be returned.)

       EENNOOEENNTT OO__CCRREEAATT  is  not set and the named file does not exist.  Or, a directory component
              in _p_a_t_h_n_a_m_e does not exist or is a dangling symbolic link.

       EENNOOEENNTT _p_a_t_h_n_a_m_e refers to a nonexistent directory,  OO__TTMMPPFFIILLEE  and  one  of  OO__WWRROONNLLYY  or
              OO__RRDDWWRR  were  specified  in  _f_l_a_g_s,  but  this kernel version does not provide the
              OO__TTMMPPFFIILLEE functionality.

       EENNOOMMEEMM Insufficient kernel memory was available.

       EENNOOSSPPCC _p_a_t_h_n_a_m_e was to be created but the device containing _p_a_t_h_n_a_m_e has no room for  the
              new file.

       EENNOOTTDDIIRR
              A  component  used  as  a  directory  in _p_a_t_h_n_a_m_e is not, in fact, a directory, or
              OO__DDIIRREECCTTOORRYY was specified and _p_a_t_h_n_a_m_e was not a directory.

       EENNXXIIOO  OO__NNOONNBBLLOOCCKK | OO__WWRROONNLLYY is set, the named file is a FIFO, and  no  process  has  the
              FIFO open for reading.  Or, the file is a device special file and no corresponding
              device exists.

       EEOOPPNNOOTTSSUUPPPP
              The filesystem containing _p_a_t_h_n_a_m_e does not support OO__TTMMPPFFIILLEE.

       EEOOVVEERRFFLLOOWW
              _p_a_t_h_n_a_m_e refers to a regular file that is too large to be opened.  The usual  sce‐
              nario  here  is  that  an  application  compiled  on  a  32-bit  platform  without
              _-_D___F_I_L_E___O_F_F_S_E_T___B_I_T_S_=_6_4 tried to open a file whose size  exceeds  _(_1_<_<_3_1_)_-_1  bytes;
              see  also  OO__LLAARRGGEEFFIILLEE  above.  This is the error specified by POSIX.1; in kernels
              before 2.6.24, Linux gave the error EEFFBBIIGG for this case.

       EEPPEERRMM  The OO__NNOOAATTIIMMEE flag was specified, but the effective user ID of the caller did  not
              match the owner of the file and the caller was not privileged (CCAAPP__FFOOWWNNEERR).

       EEPPEERRMM  The operation was prevented by a file seal; see ffccnnttll(2).

       EERROOFFSS  _p_a_t_h_n_a_m_e  refers  to  a  file  on  a  read-only  filesystem  and  write access was
              requested.

       EETTXXTTBBSSYY
              _p_a_t_h_n_a_m_e refers to an executable image which is currently being executed and write
              access was requested.

       EEWWOOUULLDDBBLLOOCCKK
              The  OO__NNOONNBBLLOOCCKK flag was specified, and an incompatible lease was held on the file
              (see ffccnnttll(2)).

       The following additional errors can occur for ooppeennaatt():

       EEBBAADDFF  _d_i_r_f_d is not a valid file descriptor.

       EENNOOTTDDIIRR
              _p_a_t_h_n_a_m_e is a relative pathname and _d_i_r_f_d is a file descriptor referring to a file
              other than a directory.

VVEERRSSIIOONNSS
       ooppeennaatt()  was added to Linux in kernel 2.6.16; library support was added to glibc in ver‐
       sion 2.4.

CCOONNFFOORRMMIINNGG TTOO
       ooppeenn(), ccrreeaatt() SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008.

       ooppeennaatt(): POSIX.1-2008.

       The OO__DDIIRREECCTT, OO__NNOOAATTIIMMEE, OO__PPAATTHH, and OO__TTMMPPFFIILLEE flags are Linux-specific.  One must define
       __GGNNUU__SSOOUURRCCEE to obtain their definitions.

       The  OO__CCLLOOEEXXEECC,  OO__DDIIRREECCTTOORRYY, and OO__NNOOFFOOLLLLOOWW flags are not specified in POSIX.1-2001, but
       are specified in POSIX.1-2008.  Since glibc 2.12, one can  obtain  their  definitions  by
       defining  either  __PPOOSSIIXX__CC__SSOOUURRCCEE  with  a  value  greater  than  or  equal to 200809L or
       __XXOOPPEENN__SSOOUURRCCEE with a value greater than or equal to 700.  In glibc 2.11 and earlier,  one
       obtains the definitions by defining __GGNNUU__SSOOUURRCCEE.

       As  noted  in  ffeeaattuurree__tteesstt__mmaaccrrooss(7),  feature  test  macros  such  as  __PPOOSSIIXX__CC__SSOOUURRCCEE,
       __XXOOPPEENN__SSOOUURRCCEE, and __GGNNUU__SSOOUURRCCEE must be defined before including _a_n_y header files.

NNOOTTEESS
       Under Linux, the OO__NNOONNBBLLOOCCKK flag indicates that one wants to open but does not  necessar‐
       ily have the intention to read or write.  This is typically used to open devices in order
       to get a file descriptor for use with iiooccttll(2).

       The (undefined) effect of OO__RRDDOONNLLYY || OO__TTRRUUNNCC varies among implementations.  On many  sys‐
       tems the file is actually truncated.

       Note  that  ooppeenn()  can  open  device  special files, but ccrreeaatt() cannot create them; use
       mmkknnoodd(2) instead.

       If the file is newly created, its _s_t___a_t_i_m_e, _s_t___c_t_i_m_e, _s_t___m_t_i_m_e fields (respectively, time
       of  last  access, time of last status change, and time of last modification; see ssttaatt(2))
       are set to the current time, and so are the _s_t___c_t_i_m_e and _s_t___m_t_i_m_e fields  of  the  parent
       directory.   Otherwise, if the file is modified because of the OO__TTRRUUNNCC flag, its _s_t___c_t_i_m_e
       and _s_t___m_t_i_m_e fields are set to the current time.

   OOppeenn ffiillee ddeessccrriippttiioonnss
       The term open file description is the one used by POSIX to refer to the  entries  in  the
       system-wide table of open files.  In other contexts, this object is variously also called
       an "open file object", a "file handle", an "open file table entry",  or—in  kernel-devel‐
       oper parlance—a _s_t_r_u_c_t _f_i_l_e.

       When  a  file descriptor is duplicated (using dduupp(2) or similar), the duplicate refers to
       the same open file description as the original file descriptor, and the two file descrip‐
       tors  consequently  share  the  file offset and file status flags.  Such sharing can also
       occur between processes: a child process created via ffoorrkk(2) inherits duplicates  of  its
       parent's file descriptors, and those duplicates refer to the same open file descriptions.

       Each  ooppeenn(2)  of a file creates a new open file description; thus, there may be multiple
       open file descriptions corresponding to a file inode.

   SSyynncchhrroonniizzeedd II//OO
       The POSIX.1-2008 "synchronized I/O" option specifies different variants  of  synchronized
       I/O,  and  specifies  the  ooppeenn()  flags OO__SSYYNNCC, OO__DDSSYYNNCC, and OO__RRSSYYNNCC for controlling the
       behavior.  Regardless of whether an implementation supports this option, it must at least
       support the use of OO__SSYYNNCC for regular files.

       Linux  implements  OO__SSYYNNCC  and  OO__DDSSYYNNCC,  but  not OO__RRSSYYNNCC.  (Somewhat incorrectly, glibc
       defines OO__RRSSYYNNCC to have the same value as OO__SSYYNNCC.)

       OO__SSYYNNCC provides synchronized I/O _f_i_l_e integrity completion, meaning write operations will
       flush data and all associated metadata to the underlying hardware.  OO__DDSSYYNNCC provides syn‐
       chronized I/O _d_a_t_a integrity completion, meaning write operations will flush data to  the
       underlying  hardware,  but  will only flush metadata updates that are required to allow a
       subsequent read operation to complete successfully.  Data integrity completion can reduce
       the  number  of  disk  operations  that are required for applications that don't need the
       guarantees of file integrity completion.

       To understand the difference between the two types of completion, consider two pieces  of
       file  metadata: the file last modification timestamp (_s_t___m_t_i_m_e) and the file length.  All
       write operations will update the last file modification timestamp, but only  writes  that
       add data to the end of the file will change the file length.  The last modification time‐
       stamp is not needed to ensure that a read completes successfully, but the file length is.
       Thus,  OO__DDSSYYNNCC would only guarantee to flush updates to the file length metadata (whereas
       OO__SSYYNNCC would also always flush the last modification timestamp metadata).

       Before Linux 2.6.33, Linux implemented only the OO__SSYYNNCC flag for  ooppeenn().   However,  when
       that  flag  was  specified, most filesystems actually provided the equivalent of synchro‐
       nized I/O _d_a_t_a integrity completion (i.e., OO__SSYYNNCC was actually implemented as the equiva‐
       lent of OO__DDSSYYNNCC).

       Since  Linux  2.6.33,  proper  OO__SSYYNNCC  support  is provided.  However, to ensure backward
       binary compatibility, OO__DDSSYYNNCC was defined with the same value as the  historical  OO__SSYYNNCC,
       and  OO__SSYYNNCC  was  defined  as  a  new (two-bit) flag value that includes the OO__DDSSYYNNCC flag
       value.  This ensures that applications compiled against new headers get at least  OO__DDSSYYNNCC
       semantics on pre-2.6.33 kernels.

   NNFFSS
       There  are  many  infelicities  in  the protocol underlying NFS, affecting amongst others
       OO__SSYYNNCC and OO__NNDDEELLAAYY.

       On NFS filesystems with UID mapping enabled, ooppeenn() may return a file descriptor but, for
       example,  rreeaadd(2)  requests  are denied with EEAACCCCEESS.  This is because the client performs
       ooppeenn() by checking the permissions, but UID mapping is performed by the server upon  read
       and write requests.

   FFIIFFOOss
       Opening  the  read  or  write end of a FIFO blocks until the other end is also opened (by
       another process or thread).  See ffiiffoo(7) for further details.

   FFiillee aacccceessss mmooddee
       Unlike the other values that can be specified in _f_l_a_g_s, the _a_c_c_e_s_s _m_o_d_e values  OO__RRDDOONNLLYY,
       OO__WWRROONNLLYY,  and  OO__RRDDWWRR do not specify individual bits.  Rather, they define the low order
       two bits of _f_l_a_g_s, and are defined respectively as 0, 1, and 2.  In other words, the com‐
       bination  OO__RRDDOONNLLYY  ||  OO__WWRROONNLLYY  is a logical error, and certainly does not have the same
       meaning as OO__RRDDWWRR.

       Linux reserves the special, nonstandard access mode 3 (binary 11) in _f_l_a_g_s to mean: check
       for  read and write permission on the file and return a descriptor that can't be used for
       reading or writing.  This nonstandard access mode is used by some Linux drivers to return
       a descriptor that is to be used only for device-specific iiooccttll(2) operations.

   RRaattiioonnaallee ffoorr ooppeennaatt(()) aanndd ootthheerr ddiirreeccttoorryy ffiillee ddeessccrriippttoorr AAPPIIss
       ooppeennaatt()  and  the  other  system  calls and library functions that take a directory file
       descriptor argument  (i.e.,  eexxeeccvveeaatt(2),  ffaacccceessssaatt(2),  ffaannoottiiffyy__mmaarrkk(2),  ffcchhmmooddaatt(2),
       ffcchhoowwnnaatt(2),  ffssttaattaatt(2),  ffuuttiimmeessaatt(2),  lliinnkkaatt(2), mmkkddiirraatt(2), mmkknnooddaatt(2), nnaammee__ttoo__hhaann‐‐
       ddllee__aatt(2), rreeaaddlliinnkkaatt(2), rreennaammeeaatt(2),  ssyymmlliinnkkaatt(2),  uunnlliinnkkaatt(2),  uuttiimmeennssaatt(2),  mmkkffii‐‐
       ffooaatt(3),  and  ssccaannddiirraatt(3))  are supported for two reasons.  Here, the explanation is in
       terms of the ooppeennaatt() call, but the rationale is analogous for the other interfaces.

       First, ooppeennaatt() allows an application to avoid race  conditions  that  could  occur  when
       using  ooppeenn()  to  open  files  in  directories other than the current working directory.
       These race conditions result from the fact that some component of  the  directory  prefix
       given to ooppeenn() could be changed in parallel with the call to ooppeenn().  Suppose, for exam‐
       ple, that we wish to create the file _p_a_t_h_/_t_o_/_x_x_x_._d_e_p if the file _p_a_t_h_/_t_o_/_x_x_x exists.  The
       problem is that between the existence check and the file creation step, _p_a_t_h or _t_o (which
       might be symbolic links) could be modified to point to a different location.  Such  races
       can be avoided by opening a file descriptor for the target directory, and then specifying
       that file descriptor as the _d_i_r_f_d argument of (say) ffssttaattaatt(2) and ooppeennaatt().

       Second, ooppeennaatt() allows the implementation of a per-thread "current  working  directory",
       via  file  descriptor(s)  maintained by the application.  (This functionality can also be
       obtained by tricks based on the use of _/_p_r_o_c_/_s_e_l_f_/_f_d_/dirfd, but less efficiently.)

   OO__DDIIRREECCTT
       The OO__DDIIRREECCTT flag may impose alignment restrictions on the length and  address  of  user-
       space  buffers  and  the  file  offset  of I/Os.  In Linux alignment restrictions vary by
       filesystem and kernel version and might be absent entirely.  However there  is  currently
       no filesystem-independent interface for an application to discover these restrictions for
       a given file or filesystem.  Some filesystems provide their own interfaces for doing  so,
       for example the XXFFSS__IIOOCC__DDIIOOIINNFFOO operation in xxffssccttll(3).

       Under Linux 2.4, transfer sizes, and the alignment of the user buffer and the file offset
       must all be multiples of the logical block size of the filesystem.   Since  Linux  2.6.0,
       alignment  to the logical block size of the underlying storage (typically 512 bytes) suf‐
       fices.  The logical block size can be determined using the iiooccttll(2)  BBLLKKSSSSZZGGEETT  operation
       or from the shell using the command:

           blockdev --getss

       OO__DDIIRREECCTT  I/Os should never be run concurrently with the ffoorrkk(2) system call, if the mem‐
       ory buffer is a private mapping (i.e., any mapping created with the  mmmmaapp(2)  MMAAPP__PPRRIIVVAATTEE
       flag;  this includes memory allocated on the heap and statically allocated buffers).  Any
       such I/Os, whether submitted via an asynchronous I/O interface or from another thread  in
       the  process,  should be completed before ffoorrkk(2) is called.  Failure to do so can result
       in data corruption and undefined behavior in parent and child processes.   This  restric‐
       tion  does  not  apply  when  the  memory  buffer for the OO__DDIIRREECCTT I/Os was created using
       sshhmmaatt(2) or mmmmaapp(2) with the MMAAPP__SSHHAARREEDD flag.  Nor does this restriction apply  when  the
       memory  buffer  has  been advised as MMAADDVV__DDOONNTTFFOORRKK with mmaaddvviissee(2), ensuring that it will
       not be available to the child after ffoorrkk(2).

       The OO__DDIIRREECCTT flag was introduced in SGI IRIX, where it has alignment restrictions similar
       to  those  of  Linux 2.4.  IRIX has also a ffccnnttll(2) call to query appropriate alignments,
       and sizes.  FreeBSD 4.x introduced a  flag  of  the  same  name,  but  without  alignment
       restrictions.

       OO__DDIIRREECCTT  support  was  added  under Linux in kernel version 2.4.10.  Older Linux kernels
       simply ignore this flag.  Some filesystems may not implement the  flag  and  ooppeenn()  will
       fail with EEIINNVVAALL if it is used.

       Applications should avoid mixing OO__DDIIRREECCTT and normal I/O to the same file, and especially
       to overlapping byte regions in the same file.  Even when the filesystem correctly handles
       the  coherency  issues  in  this situation, overall I/O throughput is likely to be slower
       than using either mode alone.  Likewise, applications  should  avoid  mixing  mmmmaapp(2)  of
       files with direct I/O to the same files.

       The  behavior of OO__DDIIRREECCTT with NFS will differ from local filesystems.  Older kernels, or
       kernels configured in certain ways, may not support this combination.  The  NFS  protocol
       does  not  support  passing  the flag to the server, so OO__DDIIRREECCTT I/O will bypass the page
       cache only on the client; the server may still cache the I/O.  The client asks the server
       to  make  the  I/O  synchronous  to preserve the synchronous semantics of OO__DDIIRREECCTT.  Some
       servers will perform poorly under these circumstances, especially  if  the  I/O  size  is
       small.   Some  servers  may  also  be  configured  to lie to clients about the I/O having
       reached stable storage; this will avoid the performance penalty  at  some  risk  to  data
       integrity in the event of server power failure.  The Linux NFS client places no alignment
       restrictions on OO__DDIIRREECCTT I/O.

       In summary, OO__DDIIRREECCTT is a potentially powerful tool that should be used with caution.  It
       is  recommended  that applications treat use of OO__DDIIRREECCTT as a performance option which is
       disabled by default.

              "The thing that has always disturbed me about O_DIRECT is that the whole interface
              is  just  stupid,  and  was probably designed by a deranged monkey on some serious
              mind-controlling substances."—Linus

BBUUGGSS
       Currently, it is not possible to enable signal-driven  I/O  by  specifying  OO__AASSYYNNCC  when
       calling ooppeenn(); use ffccnnttll(2) to enable this flag.

       One must check for two different error codes, EEIISSDDIIRR and EENNOOEENNTT, when trying to determine
       whether the kernel supports OO__TTMMPPFFIILLEE functionality.

       When both OO__CCRREEAATT and OO__DDIIRREECCTTOORRYY are specified in _f_l_a_g_s and the file specified by  _p_a_t_h_‐
       _n_a_m_e does not exist, ooppeenn() will create a regular file (i.e., OO__DDIIRREECCTTOORRYY is ignored).

SSEEEE AALLSSOO
       cchhmmoodd(2),  cchhoowwnn(2),  cclloossee(2),  dduupp(2),  ffccnnttll(2), lliinnkk(2), llsseeeekk(2), mmkknnoodd(2), mmmmaapp(2),
       mmoouunntt(2),  ooppeenn__bbyy__hhaannddllee__aatt(2),  rreeaadd(2),  ssoocckkeett(2),  ssttaatt(2),   uummaasskk(2),   uunnlliinnkk(2),
       wwrriittee(2), ffooppeenn(3), aaccll(5) ffiiffoo(7), ppaatthh__rreessoolluuttiioonn(7), ssyymmlliinnkk(7)

CCOOLLOOPPHHOONN
       This  page  is part of release 4.04 of the Linux _m_a_n_-_p_a_g_e_s project.  A description of the
       project, information about reporting bugs, and the latest version of this  page,  can  be
       found at http://www.kernel.org/doc/man-pages/.

Linux                                      2015-12-05                                    OPEN(2)
